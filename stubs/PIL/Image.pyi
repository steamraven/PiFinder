from typing import IO, Any, Callable, Iterable
from typing_extensions import TypeAlias
from . import ExifTags as ExifTags, ImageMode as ImageMode, TiffTags as TiffTags, UnidentifiedImageError as UnidentifiedImageError
from ._binary import i32le as i32le, o32be as o32be, o32le as o32le
from ._util import DeferredError as DeferredError, is_path as is_path
from _typeshed import Incomplete
from collections.abc import MutableMapping
from enum import IntEnum
from pathlib import Path

_Color: TypeAlias = (
    int | tuple[int] | tuple[int, int] | tuple[int, int, int] | tuple[int, int, int, int] | str | float | tuple[float]
)

logger: Incomplete

class DecompressionBombWarning(RuntimeWarning): ...
class DecompressionBombError(Exception): ...

MAX_IMAGE_PIXELS: Incomplete
msg: Incomplete
USE_CFFI_ACCESS: bool

def isImageType(t): ...

class Transpose(IntEnum):
    FLIP_LEFT_RIGHT: int
    FLIP_TOP_BOTTOM: int
    ROTATE_90: int
    ROTATE_180: int
    ROTATE_270: int
    TRANSPOSE: int
    TRANSVERSE: int

class Transform(IntEnum):
    AFFINE: int
    EXTENT: int
    PERSPECTIVE: int
    QUAD: int
    MESH: int

class Resampling(IntEnum):
    NEAREST: int
    BOX: int
    BILINEAR: int
    HAMMING: int
    BICUBIC: int
    LANCZOS: int

class Dither(IntEnum):
    NONE: int
    ORDERED: int
    RASTERIZE: int
    FLOYDSTEINBERG: int

class Palette(IntEnum):
    WEB: int
    ADAPTIVE: int

class Quantize(IntEnum):
    MEDIANCUT: int
    MAXCOVERAGE: int
    FASTOCTREE: int
    LIBIMAGEQUANT: int

module: Incomplete
DEFAULT_STRATEGY: Incomplete
FILTERED: Incomplete
HUFFMAN_ONLY: Incomplete
RLE: Incomplete
FIXED: Incomplete
ID: Incomplete
OPEN: Incomplete
MIME: Incomplete
SAVE: Incomplete
SAVE_ALL: Incomplete
EXTENSION: Incomplete
DECODERS: Incomplete
ENCODERS: Incomplete
MODES: Incomplete

def getmodebase(mode): ...
def getmodetype(mode): ...
def getmodebandnames(mode): ...
def getmodebands(mode): ...
def preinit() -> None: ...
def init(): ...

class _E:
    scale: Incomplete
    offset: Incomplete
    def __init__(self, scale, offset) -> None: ...
    def __neg__(self): ...
    def __add__(self, other): ...
    __radd__ = __add__
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    __rmul__ = __mul__
    def __truediv__(self, other): ...

class Image:
    format: Incomplete
    format_description: Incomplete
    im: Incomplete
    mode: str
    palette: Incomplete
    info: Incomplete
    readonly: int
    pyaccess: Incomplete
    def __init__(self) -> None: ...
    @property
    def width(self): ...
    @property
    def height(self): ...
    @property
    def size(self): ...
    def __enter__(self): ...
    fp: Incomplete
    def __exit__(self, *args) -> None: ...
    map: Incomplete
    def close(self) -> None: ...
    def __eq__(self, other): ...
    @property
    def __array_interface__(self): ...
    def tobytes(self, encoder_name: str = ..., *args): ...
    def tobitmap(self, name: str = ...): ...
    def frombytes(self, data, decoder_name: str = ..., *args) -> None: ...
    def load(self): ...
    def verify(self) -> None: ...
    def convert(self, mode: str | None = ..., matrix: Incomplete | None = ..., dither: Incomplete | None = ..., palette=..., colors: int = ...) -> Image: ...
    def quantize(self, colors: int = ..., method: Incomplete | None = ..., kmeans: int = ..., palette: Incomplete | None = ..., dither=...): ...
    def copy(self) -> Image: ...
    __copy__ = copy
    def crop(self, box:tuple[int,int,int,int] | None = ...) -> Image: ...
    def draft(self, mode, size) -> None: ...
    def filter(self, filter): ...
    def getbands(self): ...
    def getbbox(self, *, alpha_only: bool = ...): ...
    def getcolors(self, maxcolors: int = ...): ...
    def getdata(self, band: Incomplete | None = ...) -> Iterable[int]: ...
    def getextrema(self): ...
    def getexif(self): ...
    def get_child_images(self): ...
    def getim(self): ...
    def getpalette(self, rawmode: str = ...): ...
    def apply_transparency(self) -> None: ...
    def getpixel(self, xy: tuple[int,int]) -> int: ...
    def getprojection(self): ...
    def histogram(self, mask: Incomplete | None = ..., extrema: Incomplete | None = ...): ...
    def entropy(self, mask: Incomplete | None = ..., extrema: Incomplete | None = ...): ...
    def paste(self, im: Image, box: tuple[int,int] | None = ..., mask: Incomplete | None = ...) -> None: ...
    def alpha_composite(self, im, dest=..., source=...) -> None: ...
    def point(self, lut, mode: Incomplete | None = ...): ...
    def putalpha(self, alpha) -> None: ...
    def putdata(self, data, scale: float = ..., offset: float = ...) -> None: ...
    def putpalette(self, data, rawmode: str = ...) -> None: ...
    def putpixel(self, xy, value): ...
    def remap_palette(self, dest_map, source_palette: Incomplete | None = ...): ...
    def resize(self, size: tuple[int,int], resample: Incomplete | None = ..., box: Incomplete | None = ..., reducing_gap: Incomplete | None = ...) -> Image: ...
    def reduce(self, factor, box: Incomplete | None = ...): ...
    def rotate(self, angle: float, resample=..., expand: int = ..., center: Incomplete | None = ..., translate: Incomplete | None = ..., fillcolor: Incomplete | None = ...) -> Image: ...
    encoderinfo: Incomplete
    encoderconfig: Incomplete
    def save(self, fp: str | Path | IO[bytes], format: str | None = ..., ) -> None: ...
    def seek(self, frame) -> None: ...
    def show(self, title: Incomplete | None = ...) -> None: ...
    def split(self): ...
    def getchannel(self, channel: str) -> Image: ...
    def tell(self): ...
    def thumbnail(self, size, resample=..., reducing_gap: float = ...): ...
    def transform(self, size, method, data: Incomplete | None = ..., resample=..., fill: int = ..., fillcolor: Incomplete | None = ...): ...
    def transpose(self, method): ...
    def effect_spread(self, distance): ...
    def toqimage(self): ...
    def toqpixmap(self): ...

class ImagePointHandler: ...
class ImageTransformHandler: ...

def new(mode:str, size:tuple[int,int], color: _Color = ...) -> Image: ...
def frombytes(mode, size, data, decoder_name: str = ..., *args): ...
def frombuffer(mode, size, data, decoder_name: str = ..., *args): ...
def fromarray(obj: Any, mode: str | None = ...) -> Image: ...
def fromqimage(im): ...
def fromqpixmap(im): ...
def open(fp: str | Path, mode: str = ..., formats: Incomplete | None = ...) -> Image: ...
def alpha_composite(im1, im2): ...
def blend(im1, im2, alpha): ...
def composite(image1, image2, mask): ...
def eval(image: Image, func: Callable[[int], int]) -> Image: ...
def merge(mode, bands): ...
def register_open(id, factory, accept: Incomplete | None = ...) -> None: ...
def register_mime(id, mimetype) -> None: ...
def register_save(id, driver) -> None: ...
def register_save_all(id, driver) -> None: ...
def register_extension(id, extension) -> None: ...
def register_extensions(id, extensions) -> None: ...
def registered_extensions(): ...
def register_decoder(name, decoder) -> None: ...
def register_encoder(name, encoder) -> None: ...
def effect_mandelbrot(size, extent, quality): ...
def effect_noise(size, sigma): ...
def linear_gradient(mode): ...
def radial_gradient(mode): ...

class Exif(MutableMapping):
    endian: Incomplete
    bigtiff: bool
    def __init__(self) -> None: ...
    fp: Incomplete
    head: Incomplete
    def load(self, data) -> None: ...
    def load_from_fp(self, fp, offset: Incomplete | None = ...) -> None: ...
    def tobytes(self, offset: int = ...): ...
    def get_ifd(self, tag): ...
    def hide_offsets(self) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, tag): ...
    def __contains__(self, tag) -> bool: ...
    def __setitem__(self, tag, value) -> None: ...
    def __delitem__(self, tag) -> None: ...
    def __iter__(self): ...
